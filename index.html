<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–õ–µ—Å–æ–ø–∞—Ä–∫</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
            max-width: 320px;
        }
        /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–æ—Ä–∞–º—ã ‚Äî —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç —Å —Ä–∞–¥–∏–∞–ª—å–Ω–æ–π —Ç–µ–Ω—å—é, –±–µ–∑ —Ñ–æ–Ω–∞ */
        #panorama-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(0,0,0,0.9), 0 0 30px rgba(0,0,0,0.7), 0 0 45px rgba(0,0,0,0.5);
            z-index: 200;
            white-space: nowrap;
            pointer-events: none;
            /* background –∏ padding —É–¥–∞–ª–µ–Ω—ã ‚Äî —á—ë—Ä–Ω–æ–π —Ä–∞–º–∫–∏ –±–æ–ª—å—à–µ –Ω–µ—Ç */
        }
        .marker-label {
            position: absolute;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            max-width: 250px;
            word-wrap: break-word;
            pointer-events: auto !important;
            transform: translate(-50%, -100%);
            color: #333;
            border: 1px solid #f0f0f0;
            font-size: 14px;
            font-family: 'Arial', sans-serif;
            cursor: pointer;
            z-index: 101;
            opacity: 0.7;
            transition: opacity 0.3s ease, background 0.3s ease;
            text-decoration: none;
            display: block;
        }
        a.marker-label:link,
        a.marker-label:visited {
            color: #333;
            text-decoration: none;
        }
        a.marker-label:hover {
            background: white;
            opacity: 1;
            text-decoration: underline;
        }
        .marker-label:hover {
            background: white;
            box-shadow: 0 3px 15px rgba(0,0,0,0.3);
            opacity: 1;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            max-width: 90%;
        }
        button {
            margin: 0 2px;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            white-space: nowrap;
        }
        button:hover { background: #45a049; }
        button.delete { background: #f44336; }
        button.delete:hover { background: #d32f2f; }
        button.secondary { background: #2196F3; }
        button.secondary:hover { background: #1976D2; }
        #upload-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 101;
            text-align: center;
            min-width: 300px;
        }
        #upload-panel h2 { margin-top: 0; }
        #file-input {
            padding: 10px;
            background: white;
            border-radius: 5px;
            margin: 15px 0;
        }
        .hidden { display: none !important; }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #font-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 102;
            min-width: 340px;
        }
        #font-dialog h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        .dialog-row {
            margin: 10px 0;
        }
        .dialog-row label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .dialog-row select,
        .dialog-row input[type="text"],
        .dialog-row input[type="url"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            font-weight: normal;
            cursor: pointer;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        .dialog-buttons button {
            padding: 8px 15px;
        }
    </style>
</head>
<body>
    <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–æ—Ä–∞–º—ã (—Å–∫—Ä—ã—Ç –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏) -->
    <div id="panorama-title" class="hidden">–û–±—â–µ—Å—Ç–≤–µ–Ω–Ω–æ-–¥–µ–ª–æ–≤–æ–π —Ü–µ–Ω—Ç—Ä</div>

    <div id="info" class="hidden">
        <strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong><br>
        ‚Ä¢ –õ–ö–ú + –¥–≤–∏–≥–∞—Ç—å –º—ã—à—å ‚Äî –≤—Ä–∞—â–∞—Ç—å<br>
        ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ –º—ã—à–∏ ‚Äî –∑—É–º<br>
        ‚Ä¢ –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä (—Å URL –∏ —à—Ä–∏—Ñ—Ç–æ–º)<br>
        ‚Ä¢ –ü–ö–ú –ø–æ –º–∞—Ä–∫–µ—Ä—É ‚Äî —É–¥–∞–ª–∏—Ç—å<br>
        ‚Ä¢ üìå –ó–∞–ø–æ–º–Ω–∏—Ç—å –≤–∏–¥ ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π –ø–æ–≤–æ—Ä–æ—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–µ<br>
        ‚Ä¢ ‚Ü∫ –°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥ ‚Äî –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ —Ü–µ–Ω—Ç—Ä<br>
        ‚Ä¢ üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å ‚Äî –∑–∞–ø–∏—Å–∞—Ç—å –º–∞—Ä–∫–µ—Ä—ã –≤ localStorage<br>
        ‚Ä¢ üì• –≠–∫—Å–ø–æ—Ä—Ç JSON ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–∞—Ä–∫–µ—Ä—ã + —Ç–µ–∫—É—â–∏–π –≤–∏–¥ –≤ —Ñ–∞–π–ª<br>
        ‚Ä¢ üì§ –ò–º–ø–æ—Ä—Ç JSON ‚Äî –∑–∞–≥—Ä—É–∂–∞–µ—Ç –º–∞—Ä–∫–µ—Ä—ã –∏ (–µ—Å–ª–∏ –µ—Å—Ç—å) –≤–∏–¥ –∏–∑ —Ñ–∞–π–ª–∞
    </div>
    
    <div id="controls" class="hidden">
        <span>–ú–∞—Ä–∫–µ—Ä–æ–≤: <span id="marker-count">0</span></span>
        <button onclick="saveMarkers()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button onclick="clearMarkers()" class="delete">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ</button>
        <button onclick="exportMarkers()">üì• –≠–∫—Å–ø–æ—Ä—Ç JSON</button>
        <button onclick="importMarkers()">üì§ –ò–º–ø–æ—Ä—Ç JSON</button>
        <!-- –ö–Ω–æ–ø–∫–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–∏–¥–æ–º -->
        <button onclick="saveCurrentView()" class="secondary" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π –≤–∏–¥ –≤ localStorage">üìå –ó–∞–ø–æ–º–Ω–∏—Ç—å –≤–∏–¥</button>
        <button onclick="resetView()" class="secondary" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ —Ü–µ–Ω—Ç—Ä">‚Ü∫ –°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥</button>
        <!-- –°–∫—Ä—ã—Ç—ã–µ –∫–Ω–æ–ø–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞/–∏–º–ø–æ—Ä—Ç–∞ –≤–∏–¥–∞ (–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–¥–µ, –Ω–æ –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è) -->
        <button onclick="exportView()" class="secondary hidden" title="–≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–∞ –≤ —Ñ–∞–π–ª">üì§ –≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–∞</button>
        <button onclick="importView()" class="secondary hidden" title="–ò–º–ø–æ—Ä—Ç –≤–∏–¥–∞ –∏–∑ —Ñ–∞–π–ª–∞">üì• –ò–º–ø–æ—Ä—Ç –≤–∏–¥–∞</button>
    </div>

    <!-- –î–∏–∞–ª–æ–≥ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —à—Ä–∏—Ñ—Ç–∞ –∏ –≥–∏–ø–µ—Ä—Å—Å—ã–ª–∫–∏ -->
    <div id="font-dialog" class="hidden">
        <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–µ—Ç–∫–∏</h3>
        <div class="dialog-row">
            <label>–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞:</label>
            <input type="range" id="dialog-font-size" min="10" max="24" value="14" step="1">
            <span id="dialog-font-size-value">14px</span>
        </div>
        <div class="dialog-row">
            <label>–®—Ä–∏—Ñ—Ç:</label>
            <select id="dialog-font-family">
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Times New Roman', serif">Times New Roman</option>
                <option value="'Courier New', monospace">Courier New</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="Georgia, serif">Georgia</option>
            </select>
        </div>
        <div class="dialog-row">
            <label>–ù–∞—á–µ—Ä—Ç–∞–Ω–∏–µ:</label>
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="dialog-font-bold"> –ñ–∏—Ä–Ω—ã–π
                </label>
                <label>
                    <input type="checkbox" id="dialog-font-italic"> –ö—É—Ä—Å–∏–≤
                </label>
            </div>
        </div>
        <div class="dialog-row">
            <label>–ì–∏–ø–µ—Ä—Å—Å—ã–ª–∫–∞ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ):</label>
            <input type="url" id="dialog-url" placeholder="https://example.com">
        </div>
        <div class="dialog-buttons">
            <button onclick="cancelFontDialog()" class="delete">–û—Ç–º–µ–Ω–∞</button>
            <button onclick="applyFontSettings()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        </div>
    </div>

    <div id="upload-panel">
        <div id="loading-indicator" class="hidden">
            <h2>–ó–∞–≥—Ä—É–∑–∫–∞ –ø–∞–Ω–æ—Ä–∞–º—ã...</h2>
            <div class="loader"></div>
            <p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ</p>
        </div>
        <div id="manual-upload">
            <h2>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø–∞–Ω–æ—Ä–∞–º—É 360¬∞</h2>
            <p>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –ø–∞–Ω–æ—Ä–∞–º—ã (JPG –∏–ª–∏ PNG):</p>
            <input type="file" id="file-input" accept=".jpg,.jpeg,.png,.bmp">
            <p style="font-size: 12px; color: #ccc; margin-top: 20px;">
                –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞, CORS –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==========
        const CONFIG = {
            markersFile: 'markers.json',
            storageKey: 'panorama-markers',
            viewStorageKey: 'panorama-initial-view',
            sphereRadius: 500,
            markerColor: 0xff0000,
            markerSize: 5.0,
            showMarkerDots: false
        };

        // ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
        let scene, camera, renderer, sphere;
        let markers = [];
        let markerContainer;
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;
        
        let sphereRotation = { x: 0, y: 0 };
        
        let velocity = { x: 0, y: 0 };
        let friction = 0.8;
        let isInertia = false;
        
        let fov = 75;
        let minFov = 10;
        let maxFov = 120;
        let targetFov = fov;
        let zoomVelocity = 0;
        let zoomFriction = 0.8;
        
        let fontDialogCallback = null;
        let pendingMarkerCoords = null;
        let pendingMarkerText = '';

        // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø THREE.JS ==========
        function initThreeJS() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            markerContainer = document.createElement('div');
            markerContainer.id = 'marker-container';
            document.body.appendChild(markerContainer);
        }

        // ========== –°–û–ó–î–ê–ù–ò–ï –¢–ï–ö–°–¢–£–†–´ ==========
        function createTextureFromImage(img) {
            const texture = new THREE.Texture();
            texture.image = img;
            texture.format = THREE.RGBAFormat;
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
    
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = -1;
            texture.offset.x = 1;
            texture.needsUpdate = true;
    
            return texture;
        }

        // ========== –ü–û–ö–ê–ó –ó–ê–ì–û–õ–û–í–ö–ê –ü–ê–ù–û–†–ê–ú–´ ==========
        function showPanoramaTitle() {
            const titleEl = document.getElementById('panorama-title');
            titleEl.textContent = document.title;
            titleEl.classList.remove('hidden');
        }

        // ========== –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –ó–ê–ì–†–£–ó–ö–ê –ü–ê–ù–û–†–ê–ú–´ ==========
        function tryLoadPanorama() {
            return new Promise((resolve, reject) => {
                document.getElementById('loading-indicator').classList.remove('hidden');
                document.getElementById('manual-upload').classList.add('hidden');
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    console.log('–ü–∞–Ω–æ—Ä–∞–º–∞ panorama.jpg –Ω–∞–π–¥–µ–Ω–∞');
                    const texture = createTextureFromImage(img);
                    const geometry = new THREE.SphereGeometry(CONFIG.sphereRadius, 60, 40);
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
                    sphere = new THREE.Mesh(geometry, material);
                    scene.add(sphere);
                    
                    document.getElementById('upload-panel').classList.add('hidden');
                    document.getElementById('info').classList.remove('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    showPanoramaTitle();
                    resolve(texture);
                };
                img.onerror = function() {
                    console.log('–ü–∞–Ω–æ—Ä–∞–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –∑–∞–≥—Ä—É–∑–∫–∏');
                    document.getElementById('loading-indicator').classList.add('hidden');
                    document.getElementById('manual-upload').classList.remove('hidden');
                    reject(new Error('–ü–∞–Ω–æ—Ä–∞–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'));
                };
                img.src = 'panorama.jpg?' + new Date().getTime();
            });
        }

        // ========== –ó–ê–ì–†–£–ó–ö–ê –ü–ê–ù–û–†–ê–ú–´ –ò–ó –§–ê–ô–õ–ê ==========
        function loadPanoramaFromFile(file) {
            return new Promise((resolve, reject) => {
                document.getElementById('loading-indicator').classList.remove('hidden');
                document.getElementById('manual-upload').classList.add('hidden');
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const texture = createTextureFromImage(img);
                        const geometry = new THREE.SphereGeometry(CONFIG.sphereRadius, 60, 40);
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
                        sphere = new THREE.Mesh(geometry, material);
                        scene.add(sphere);
                        
                        document.getElementById('upload-panel').classList.add('hidden');
                        document.getElementById('info').classList.remove('hidden');
                        document.getElementById('controls').classList.remove('hidden');
                        showPanoramaTitle();
                        resolve(texture);
                    };
                    img.onerror = () => reject(new Error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è'));
                    img.src = event.target.result;
                };
                reader.onerror = () => reject(new Error('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞'));
                reader.readAsDataURL(file);
            });
        }

        // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô ==========
        function initControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                    isInertia = false;
                    velocity = { x: 0, y: 0 };
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    e.preventDefault();
                }
            });
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                velocity.x = deltaX * rotationSpeed * 0.5;
                velocity.y = deltaY * rotationSpeed * 0.5;
                sphereRotation.y += deltaX * rotationSpeed;
                sphereRotation.x += deltaY * rotationSpeed;
                sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                if (sphere) {
                    sphere.rotation.y = sphereRotation.y;
                    sphere.rotation.x = sphereRotation.x;
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isDragging = false;
                    isInertia = true;
                }
            });
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomStep = 10;
                if (e.deltaY < 0) targetFov = Math.max(minFov, fov - zoomStep);
                else targetFov = Math.min(maxFov, fov + zoomStep);
                zoomVelocity = (targetFov - fov) * 0.3;
            });
        }

        // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –í–ò–î–û–ú ==========
        function saveCurrentView() {
            if (!sphere) { alert('–ü–∞–Ω–æ—Ä–∞–º–∞ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞'); return; }
            const viewData = { x: sphereRotation.x, y: sphereRotation.y };
            localStorage.setItem(CONFIG.viewStorageKey, JSON.stringify(viewData));
            alert('–¢–µ–∫—É—â–∏–π –≤–∏–¥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –±—Ä–∞—É–∑–µ—Ä–µ');
        }

        function loadInitialView() {
            const saved = localStorage.getItem(CONFIG.viewStorageKey);
            if (saved) {
                try {
                    const viewData = JSON.parse(saved);
                    sphereRotation.x = viewData.x || 0;
                    sphereRotation.y = viewData.y || 0;
                    sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                    if (sphere) {
                        sphere.rotation.y = sphereRotation.y;
                        sphere.rotation.x = sphereRotation.x;
                    }
                    console.log('–ó–∞–≥—Ä—É–∂–µ–Ω –Ω–∞—á–∞–ª—å–Ω—ã–π –≤–∏–¥');
                } catch (e) { console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–∞:', e); }
            }
        }

        function resetView() {
            if (!sphere) return;
            sphereRotation = { x: 0, y: 0 };
            sphere.rotation.y = 0;
            sphere.rotation.x = 0;
            velocity = { x: 0, y: 0 };
            isInertia = false;
            console.log('–í–∏–¥ —Å–±—Ä–æ—à–µ–Ω –≤ —Ü–µ–Ω—Ç—Ä');
        }

        // ========== –≠–ö–°–ü–û–†–¢ / –ò–ú–ü–û–†–¢ –í–ò–î–ê –í –§–ê–ô–õ (—Å–∫—Ä—ã—Ç—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª) ==========
        function exportView() {
            if (!sphere) { alert('–ü–∞–Ω–æ—Ä–∞–º–∞ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞'); return; }
            const viewData = { x: sphereRotation.x, y: sphereRotation.y };
            const dataStr = JSON.stringify(viewData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'view.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importView() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const viewData = JSON.parse(event.target.result);
                        if (typeof viewData.x === 'number' && typeof viewData.y === 'number') {
                            sphereRotation.x = viewData.x;
                            sphereRotation.y = viewData.y;
                            sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                            if (sphere) {
                                sphere.rotation.y = sphereRotation.y;
                                sphere.rotation.x = sphereRotation.x;
                            }
                            localStorage.setItem(CONFIG.viewStorageKey, JSON.stringify(viewData));
                            alert('–í–∏–¥ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞ –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω—ã–π');
                        } else {
                            alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –≤–∏–¥–∞');
                        }
                    } catch (error) {
                        alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ========== –ú–ê–†–ö–ï–†–´ ==========
        function addMarker(coords, label = '–ù–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä', id = Date.now().toString(), 
                          fontSize = 14, fontFamily = 'Arial, sans-serif', 
                          fontWeight = 'normal', fontStyle = 'normal', url = '') {
            let markerMesh = null;
            if (CONFIG.showMarkerDots) {
                const geometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: CONFIG.markerColor, transparent: true, opacity: 0.7 });
                markerMesh = new THREE.Mesh(geometry, material);
                const vector = new THREE.Vector3();
                vector.setFromSphericalCoords(CONFIG.sphereRadius, coords.phi, coords.theta);
                markerMesh.position.copy(vector);
                scene.add(markerMesh);
            }
            
            let labelElement;
            if (url && url.trim() !== '') {
                labelElement = document.createElement('a');
                labelElement.href = url;
                labelElement.target = '_blank';
                labelElement.rel = 'noopener noreferrer';
            } else {
                labelElement = document.createElement('div');
            }
            labelElement.className = 'marker-label';
            labelElement.textContent = label;
            labelElement.dataset.markerId = id;
            labelElement.style.fontSize = fontSize + 'px';
            labelElement.style.fontFamily = fontFamily;
            labelElement.style.fontWeight = fontWeight;
            labelElement.style.fontStyle = fontStyle;
            
            labelElement.addEventListener('contextmenu', function(e) {
                e.preventDefault(); e.stopPropagation();
                if (confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –º–∞—Ä–∫–µ—Ä?')) { removeMarker(id); saveMarkers(); }
                return false;
            });
            labelElement.addEventListener('mouseenter', function() {
                this.style.background = 'white'; this.style.opacity = '1';
                const marker = markers.find(m => m.id === id);
                if (marker && marker.mesh && marker.mesh.material) marker.mesh.material.opacity = 1;
            });
            labelElement.addEventListener('mouseleave', function() {
                this.style.background = 'white'; this.style.opacity = '0.7';
                const marker = markers.find(m => m.id === id);
                if (marker && marker.mesh && marker.mesh.material) marker.mesh.material.opacity = 0.7;
            });
            markerContainer.appendChild(labelElement);
            
            markers.push({
                id, mesh: markerMesh, label: labelElement, coords, text: label,
                fontSize, fontFamily, fontWeight, fontStyle, url,
                date: new Date().toISOString()
            });
            updateMarkerCount();
            updateMarkerLabels();
            return id;
        }

        function removeMarker(id) {
            const index = markers.findIndex(m => m.id === id);
            if (index !== -1) {
                if (markers[index].mesh) { scene.remove(markers[index].mesh); markers[index].mesh.geometry.dispose(); markers[index].mesh.material.dispose(); }
                if (markers[index].label.parentNode) markerContainer.removeChild(markers[index].label);
                markers.splice(index, 1);
                updateMarkerCount();
                return true;
            }
            return false;
        }

        function getSphericalCoords(event) {
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            if (!sphere) return null;
            const tempSphere = new THREE.Sphere(new THREE.Vector3(0,0,0), CONFIG.sphereRadius);
            const intersection = raycaster.ray.intersectSphere(tempSphere, new THREE.Vector3());
            if (intersection) {
                const intersectionPoint = intersection.clone();
                const quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(sphereRotation.x, sphereRotation.y, 0));
                intersectionPoint.applyQuaternion(quaternion.inverse());
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(intersectionPoint);
                return spherical;
            }
            return null;
        }

        function updateMarkerLabels() {
            markers.forEach(marker => {
                const position = new THREE.Vector3();
                position.setFromSphericalCoords(CONFIG.sphereRadius, marker.coords.phi, marker.coords.theta);
                if (marker.mesh) marker.mesh.position.copy(position);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(sphereRotation.x, sphereRotation.y, 0));
                const rotatedPosition = position.clone().applyQuaternion(quaternion);
                const vector = rotatedPosition.clone().project(camera);
                if (vector.z < 1) {
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    marker.label.style.display = 'block';
                    marker.label.style.left = `${x}px`;
                    marker.label.style.top = `${y}px`;
                } else marker.label.style.display = 'none';
            });
        }

        function updateMarkerCount() {
            document.getElementById('marker-count').textContent = markers.length;
        }

        // ========== –î–ò–ê–õ–û–ì –ù–ê–°–¢–†–û–ï–ö ==========
        function showFontDialog(text, callback, currentUrl = '') {
            pendingMarkerText = text;
            fontDialogCallback = callback;
            document.getElementById('font-dialog').classList.remove('hidden');
            const fontSizeSlider = document.getElementById('dialog-font-size');
            const fontSizeValue = document.getElementById('dialog-font-size-value');
            fontSizeSlider.value = '14';
            fontSizeValue.textContent = '14px';
            fontSizeSlider.oninput = (e) => fontSizeValue.textContent = e.target.value + 'px';
            document.getElementById('dialog-url').value = currentUrl;
        }

        function cancelFontDialog() {
            document.getElementById('font-dialog').classList.add('hidden');
            fontDialogCallback = null;
            pendingMarkerText = '';
        }

        function applyFontSettings() {
            const fontSize = document.getElementById('dialog-font-size').value;
            const fontFamily = document.getElementById('dialog-font-family').value;
            const isBold = document.getElementById('dialog-font-bold').checked;
            const isItalic = document.getElementById('dialog-font-italic').checked;
            const url = document.getElementById('dialog-url').value.trim();
            const fontWeight = isBold ? 'bold' : 'normal';
            const fontStyle = isItalic ? 'italic' : 'normal';
            document.getElementById('font-dialog').classList.add('hidden');
            if (fontDialogCallback) {
                fontDialogCallback(fontSize, fontFamily, fontWeight, fontStyle, url);
                fontDialogCallback = null;
            }
            pendingMarkerText = '';
        }

        // ========== –°–û–•–†–ê–ù–ï–ù–ò–ï / –ó–ê–ì–†–£–ó–ö–ê –ú–ê–†–ö–ï–†–û–í (localStorage) ==========
        function saveMarkers() {
            const markersData = markers.map(m => ({
                id: m.id, theta: m.coords.theta, phi: m.coords.phi, text: m.text,
                fontSize: m.fontSize, fontFamily: m.fontFamily, fontWeight: m.fontWeight, fontStyle: m.fontStyle,
                url: m.url || '', date: m.date
            }));
            localStorage.setItem(CONFIG.storageKey, JSON.stringify(markersData));
            alert(`–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${markers.length} –º–∞—Ä–∫–µ—Ä–æ–≤ –≤ localStorage`);
        }

function loadMarkers() {
  // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å markers.json
  fetch(CONFIG.markersFile)
    .then(response => {
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return response.json();
    })
    .then(data => {
      // –ï—Å–ª–∏ –≤ —Ñ–∞–π–ª–µ –µ—Å—Ç—å –æ–±—ä–µ–∫—Ç —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏ –∏/–∏–ª–∏ –≤–∏–¥–æ–º
      let markersData = [];
      let viewData = null;

      if (Array.isArray(data)) {
        // –ü—Ä–æ—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –º–∞—Ä–∫–µ—Ä–æ–≤
        markersData = data;
      } else if (data && typeof data === 'object') {
        // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: { markers: [...], view: {...} }
        if (Array.isArray(data.markers)) markersData = data.markers;
        if (data.view && typeof data.view.x === 'number' && typeof data.view.y === 'number') {
          viewData = data.view;
        }
      }

      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–∞—Ä–∫–µ—Ä—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
      markers.forEach(m => {
        if (m.mesh) scene.remove(m.mesh);
        if (m.label.parentNode) markerContainer.removeChild(m.label);
      });
      markers = [];

      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –º–∞—Ä–∫–µ—Ä—ã –∏–∑ —Ñ–∞–π–ª–∞
      markersData.forEach(markerData => {
        addMarker(
          { theta: markerData.theta, phi: markerData.phi },
          markerData.text,
          markerData.id,
          markerData.fontSize || 14,
          markerData.fontFamily || 'Arial, sans-serif',
          markerData.fontWeight || 'normal',
          markerData.fontStyle || 'normal',
          markerData.url || ''
        );
      });

      // –ï—Å–ª–∏ –≤ —Ñ–∞–π–ª–µ –±—ã–ª view ‚Äì –ø—Ä–∏–º–µ–Ω—è–µ–º –µ–≥–æ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω—ã–π
      if (viewData) {
        sphereRotation.x = viewData.x;
        sphereRotation.y = viewData.y;
        sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
        if (sphere) {
          sphere.rotation.y = sphereRotation.y;
          sphere.rotation.x = sphereRotation.x;
        }
        localStorage.setItem(CONFIG.viewStorageKey, JSON.stringify(viewData));
        console.log('–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤–∏–¥ –∏–∑ markers.json');
      }

      updateMarkerCount();
      console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${markers.length} –º–∞—Ä–∫–µ—Ä–æ–≤ –∏–∑ ${CONFIG.markersFile}`);
    })
    .catch(error => {
      console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å markers.json:', error);
      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –Ω–æ –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ localStorage
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã –∏–∑ —Ñ–∞–π–ª–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ markers.json –≤ –∫–æ—Ä–Ω–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è.');
    });
}

        function clearMarkers() {
            if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–∞—Ä–∫–µ—Ä—ã?')) {
                markers.forEach(m => { if (m.mesh) scene.remove(m.mesh); if (m.label.parentNode) markerContainer.removeChild(m.label); });
                markers = [];
                localStorage.removeItem(CONFIG.storageKey);
                updateMarkerCount();
            }
        }

        // ========== –≠–ö–°–ü–û–†–¢ / –ò–ú–ü–û–†–¢ JSON (–ú–ê–†–ö–ï–†–´ + –í–ò–î) ==========
        function exportMarkers() {
            const markersData = markers.map(m => ({
                id: m.id, theta: m.coords.theta, phi: m.coords.phi, text: m.text,
                fontSize: m.fontSize, fontFamily: m.fontFamily, fontWeight: m.fontWeight, fontStyle: m.fontStyle,
                url: m.url || '', date: m.date
            }));
            const exportObj = {
                markers: markersData,
                view: { x: sphereRotation.x, y: sphereRotation.y }
            };
            const dataStr = JSON.stringify(exportObj, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'markers_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importMarkers() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const imported = JSON.parse(event.target.result);
                        
                        let markersData = [];
                        let viewData = null;
                        
                        if (Array.isArray(imported)) {
                            markersData = imported;
                        } else if (imported && typeof imported === 'object') {
                            if (Array.isArray(imported.markers)) markersData = imported.markers;
                            if (imported.view && typeof imported.view.x === 'number' && typeof imported.view.y === 'number') {
                                viewData = imported.view;
                            }
                        }
                        
                        markers.forEach(m => { if (m.mesh) scene.remove(m.mesh); if (m.label.parentNode) markerContainer.removeChild(m.label); });
                        markers = [];
                        
                        markersData.forEach(markerData => {
                            addMarker(
                                { theta: markerData.theta, phi: markerData.phi },
                                markerData.text,
                                markerData.id,
                                markerData.fontSize || 14,
                                markerData.fontFamily || 'Arial, sans-serif',
                                markerData.fontWeight || 'normal',
                                markerData.fontStyle || 'normal',
                                markerData.url || ''
                            );
                        });
                        
                        if (viewData) {
                            sphereRotation.x = viewData.x;
                            sphereRotation.y = viewData.y;
                            sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                            if (sphere) {
                                sphere.rotation.y = sphereRotation.y;
                                sphere.rotation.x = sphereRotation.x;
                            }
                            localStorage.setItem(CONFIG.viewStorageKey, JSON.stringify(viewData));
                            alert(`–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ ${markersData.length} –º–∞—Ä–∫–µ—Ä–æ–≤ –∏ –≤–∏–¥`);
                        } else {
                            alert(`–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ ${markersData.length} –º–∞—Ä–∫–µ—Ä–æ–≤`);
                        }
                        
                        updateMarkerCount();
                        saveMarkers();
                    } catch(error) {
                        alert('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ==========
        function initEventHandlers() {
            renderer.domElement.addEventListener('dblclick', (event) => {
                if (!sphere) { alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø–∞–Ω–æ—Ä–∞–º—É!'); return; }
                const coords = getSphericalCoords(event);
                if (coords) {
                    const label = prompt('–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å—å –¥–ª—è –º–∞—Ä–∫–µ—Ä–∞:', '–ù–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä');
                    if (label && label.trim() !== '') {
                        pendingMarkerCoords = coords;
                        showFontDialog(label, (fontSize, fontFamily, fontWeight, fontStyle, url) => {
                            addMarker(pendingMarkerCoords, label, undefined, 
                                     parseInt(fontSize), fontFamily, fontWeight, fontStyle, url);
                            saveMarkers();
                            pendingMarkerCoords = null;
                        }, '');
                    }
                }
            });
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            document.getElementById('file-input').addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file || !file.type.match('image.*')) { alert('–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); return; }
                try {
                    await loadPanoramaFromFile(file);
                    initControls();
                    loadMarkers();
                    loadInitialView();
                    animate();
                } catch (error) {
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
                    document.getElementById('loading-indicator').classList.add('hidden');
                    document.getElementById('manual-upload').classList.remove('hidden');
                }
            });
        }

        // ========== –ê–ù–ò–ú–ê–¶–ò–Ø ==========
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateMarkerLabels();
            renderer.render(scene, camera);
        }

        function updatePhysics() {
            if (isInertia && !isDragging) {
                sphereRotation.y += velocity.x;
                sphereRotation.x += velocity.y;
                sphereRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphereRotation.x));
                if (sphere) { sphere.rotation.y = sphereRotation.y; sphere.rotation.x = sphereRotation.x; }
                velocity.x *= friction; velocity.y *= friction;
                if (Math.abs(velocity.x) < 0.0001 && Math.abs(velocity.y) < 0.0001) { velocity = { x:0, y:0 }; isInertia = false; }
            }
            if (Math.abs(zoomVelocity) > 0.01) {
                fov += zoomVelocity; zoomVelocity *= zoomFriction;
                fov = Math.max(minFov, Math.min(maxFov, fov));
                camera.fov = fov; camera.updateProjectionMatrix();
            }
        }

        // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
        async function init() {
            initThreeJS();
            initEventHandlers();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            try {
                await tryLoadPanorama();
                initControls();
                loadMarkers();
                loadInitialView();
                animate();
            } catch (error) { console.log('–ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å, –∂–¥—ë–º —Ä—É—á–Ω—É—é'); }
            
            window.saveMarkers = saveMarkers;
            window.clearMarkers = clearMarkers;
            window.exportMarkers = exportMarkers;
            window.importMarkers = importMarkers;
            window.cancelFontDialog = cancelFontDialog;
            window.applyFontSettings = applyFontSettings;
            window.saveCurrentView = saveCurrentView;
            window.resetView = resetView;
            window.exportView = exportView;
            window.importView = importView;
        }

        init();
    </script>
</body>
</html>